

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>COSIE.data_preprocessing &mdash; COSIE 1.0, 2025-04 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/readthedocs-custom.css?v=1524ae53" />

  
      <script src="../../_static/documentation_options.js?v=59fcc1ed"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">COSIE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">COSIE.data_preprocessing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for COSIE.data_preprocessing</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">anndata</span> <span class="k">as</span> <span class="nn">ad</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>



<div class="viewcode-block" id="preprocess_adata">
<a class="viewcode-back" href="../../api/COSIE.data_preprocessing.preprocess_adata.html#COSIE.data_preprocessing.preprocess_adata">[docs]</a>
<span class="k">def</span> <span class="nf">preprocess_adata</span><span class="p">(</span><span class="n">adata_raw</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="n">hvg_num</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">target_sum</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Preprocess an AnnData object based on the specified modality. The pipeline includes highly variable feature selection, normalization, log-transformation, scaling, and PCA.</span>

<span class="sd">    This function supports preprocessing of epigenomic, RNA, protein, metabolite, and histology embedding (HE) modalities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata_raw : AnnData</span>
<span class="sd">        The raw AnnData object to be processed.</span>
<span class="sd">    </span>
<span class="sd">    modality : str</span>
<span class="sd">        The modality type. Must be one of:</span>
<span class="sd">        </span>
<span class="sd">        - `&#39;RNA&#39;`, `&#39;RNA_panel2&#39;`: RNA count matrix, supports different panels within the same RNA modality.</span>
<span class="sd">        - `&#39;H3K27me3&#39;`, `&#39;H3K27ac&#39;`, `&#39;ATAC&#39;`, `&#39;H3K4me3&#39;`: Epigenomic signals.  </span>
<span class="sd">          We recommend first converting raw epigenomics data to gene scores before using this function.</span>
<span class="sd">          Gene score generation scripts are available at spatial-Mux-seq Repository.  </span>
<span class="sd">        - `&#39;Protein&#39;`: Protein abundance matrix; CLR normalization will be applied. For COMET protein data, we recommend using arcsinh normalization.</span>
<span class="sd">        - `&#39;Metabolite&#39;`: Metabolite expression matrix.  </span>
<span class="sd">        - `&#39;HE&#39;`: Histology image embeddings; PCA will be applied directly without normalization.</span>
<span class="sd">    </span>
<span class="sd">    hvg_num : int, optional</span>
<span class="sd">        Number of highly variable features to select. If None, HVG selection is skipped. Default is 3000.</span>
<span class="sd">    </span>
<span class="sd">    n_comps : int, optional</span>
<span class="sd">        Number of PCA components to compute. Default is 50.</span>
<span class="sd">    </span>
<span class="sd">    target_sum : float or None, optional</span>
<span class="sd">        Target sum for total-count normalization (used in `normalize_total`). If None, the Scanpy default is used. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">        A preprocessed AnnData object with normalized, log-transformed, scaled, and PCA-reduced `.X`. For protein modality, CLR normalization is used. HVG selection is only applied if `hvg_num` is provided and the number of input features exceeds this threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adata</span> <span class="o">=</span> <span class="n">adata_raw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var_names_make_unique</span><span class="p">()</span>
    <span class="c1"># print(f&#39;Processing data... Modality: {modality}&#39;)</span>

    <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;HE&#39;</span><span class="p">:</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">hvg_num</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span><span class="o">&gt;</span><span class="n">hvg_num</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">modality</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;RNA&quot;</span><span class="p">,</span> <span class="s2">&quot;RNA_panel2&quot;</span><span class="p">,</span><span class="s2">&quot;H3K27me3&quot;</span><span class="p">,</span> <span class="s2">&quot;H3K27ac&quot;</span><span class="p">,</span> <span class="s2">&quot;ATAC&quot;</span><span class="p">,</span> <span class="s2">&quot;H3K4me3&quot;</span><span class="p">,</span> <span class="s2">&quot;Metabolite&quot;</span><span class="p">}:</span>
                <span class="n">use_batch</span> <span class="o">=</span> <span class="s1">&#39;batch&#39;</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span>
                <span class="c1"># print(f&#39;Selecting HVG for {modality} {&quot;with batch key&quot; if use_batch else &quot;without batch key&quot;}&#39;)</span>
                <span class="k">if</span> <span class="n">modality</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">,</span> <span class="s2">&quot;RNA_panel2&quot;</span><span class="p">]:</span>
                    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">highly_variable_genes</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">hvg_num</span><span class="p">,</span> <span class="n">flavor</span><span class="o">=</span><span class="s2">&quot;seurat_v3&quot;</span><span class="p">,</span> <span class="n">batch_key</span><span class="o">=</span><span class="s1">&#39;batch&#39;</span> <span class="k">if</span> <span class="n">use_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">highly_variable_genes</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_top_genes</span><span class="o">=</span><span class="n">hvg_num</span><span class="p">,</span> <span class="n">batch_key</span><span class="o">=</span><span class="s1">&#39;batch&#39;</span> <span class="k">if</span> <span class="n">use_batch</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;highly_variable&#39;</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s2">&quot;Protein&quot;</span><span class="p">:</span>
            <span class="n">adata</span> <span class="o">=</span> <span class="n">clr_normalize_each_cell</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>  
            <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
            <span class="c1"># adata.X = np.arcsinh(adata.X / 5)   ### For COMET data</span>
            <span class="c1"># print(&#39;using arcsinh&#39;)</span>
            <span class="n">n_proteins</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">n_proteins</span> <span class="o">&gt;=</span> <span class="n">n_comps</span><span class="p">:</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n_proteins</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">:</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target_sum</span><span class="p">:</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">normalize_total</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">target_sum</span><span class="o">=</span><span class="n">target_sum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">normalize_total</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adata</span></div>




<div class="viewcode-block" id="load_data">
<a class="viewcode-back" href="../../api/COSIE.data_preprocessing.load_data.html#COSIE.data_preprocessing.load_data">[docs]</a>
<span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">hvg_num</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">target_sum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_harmony</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">metacell</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process input spatial multi-modal data, returning processed feature matrices and spatial coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Shared modalities that appear in multiple sections are concatenated and jointly processed.</span>
<span class="sd">    Unique modalities (only present in one section) are processed independently. Each section&#39;s feature matrix is stored</span>
<span class="sd">    as a PyTorch tensor for downstream modeling. Spatial coordinates are checked for consistency across modalities; if</span>
<span class="sd">    inconsistent within a section, an error is raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        A dictionary mapping each modality name (e.g., `&#39;RNA&#39;`, `&#39;Protein&#39;`) to a list of AnnData objects, one per tissue section. Each AnnData should contain `.X`, `.obs`, `.var`, and `.obsm[&#39;spatial&#39;]`. If a modality is missing from a section, use `None` as a placeholder in the list.</span>
<span class="sd">    </span>
<span class="sd">    n_comps : int, optional</span>
<span class="sd">        Number of PCA components to compute. Default is 50.</span>
<span class="sd">    </span>
<span class="sd">    hvg_num : int, optional</span>
<span class="sd">        Number of highly variable features to select. If the feature dimension is smaller than `hvg_num`, HVG selection is skipped. Default is 3000.</span>
<span class="sd">    </span>
<span class="sd">    target_sum : float or None, optional</span>
<span class="sd">        Target sum for total-count normalization (used in `scanpy.pp.normalize_total`). If None, Scanpy default is used. Default is None.</span>
<span class="sd">    </span>
<span class="sd">    use_harmony : bool, optional</span>
<span class="sd">        Whether to perform Harmony integration across sections for shared modalities. If False, only joint PCA is applied. Default is True.</span>
<span class="sd">    </span>
<span class="sd">    metacell : bool, optional</span>
<span class="sd">        Whether to merge each 2×2 spatial grid of cells into a &quot;metacell&quot; for reducing memory usage and improving speed. Applies to all modalities. Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    feature_dict : dict</span>
<span class="sd">        A dictionary mapping each section name (e.g., `&#39;s1&#39;`, `&#39;s2&#39;`) to a sub-dictionary of processed feature tensors for each modality. Each feature is a `torch.FloatTensor` of shape (n_cells, n_comps).</span>
<span class="sd">    </span>
<span class="sd">    spatial_loc_dict : dict</span>
<span class="sd">        A dictionary mapping each section name to a 2D NumPy array of spatial coordinates, extracted from `.obsm[&#39;spatial&#39;]`. Shape is (n_cells, 2).</span>
<span class="sd">    </span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        The updated input dictionary. Each AnnData object is modified to include reduced features (e.g., PCA or Harmony output) in `.obsm`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">metacell</span><span class="p">:</span>
        <span class="c1"># This will combine every 2x2 adjacent cells into a meta-cell across all modalities.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Combine adjacent 4 cells into metacell to save memory and speed up computation&#39;</span><span class="p">)</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="n">construct_metacell_data_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>
        

    <span class="n">feature_dict</span> <span class="o">=</span> <span class="p">{}</span>   
    <span class="n">spatial_loc_dict</span> <span class="o">=</span> <span class="p">{}</span>  
    <span class="n">num_sections</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sections</span><span class="p">)</span> <span class="k">for</span> <span class="n">sections</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> 

    <span class="c1"># Detect shared modality</span>
    <span class="n">shared_modalities</span> <span class="o">=</span> <span class="p">{</span><span class="n">modality</span><span class="p">:</span> <span class="p">[</span><span class="n">adata</span> <span class="k">for</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">sections</span> <span class="k">if</span> <span class="n">adata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span> 
                         <span class="k">for</span> <span class="n">modality</span><span class="p">,</span> <span class="n">sections</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                         <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>
    
    <span class="c1"># print(&#39;Shared modalities:&#39;, shared_modalities)</span>
    <span class="n">shared_modality_sections</span> <span class="o">=</span> <span class="p">{</span><span class="n">modality</span><span class="p">:</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_dict</span><span class="p">[</span><span class="n">modality</span><span class="p">])</span> <span class="k">if</span> <span class="n">adata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">modality</span> <span class="ow">in</span> <span class="n">shared_modalities</span><span class="p">}</span>
    
    <span class="c1"># Process shared modality</span>
    <span class="k">for</span> <span class="n">modality</span><span class="p">,</span> <span class="n">adata_list</span> <span class="ow">in</span> <span class="n">shared_modalities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-------- Processing shared modality </span><span class="si">{</span><span class="n">modality</span><span class="si">}</span><span class="s1"> across sections --------&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;HE&#39;</span><span class="p">:</span>
            <span class="n">adata_sub_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adata_list</span><span class="p">):</span>
                <span class="n">adata_sub</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">adata_sub</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">=</span> <span class="n">adata_sub</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">shared_modality_sections</span><span class="p">[</span><span class="n">modality</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">adata_sub_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adata_sub</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">common_var_names</span> <span class="o">=</span> <span class="n">adata_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">var_names</span>
            <span class="k">for</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">common_var_names</span> <span class="o">=</span> <span class="n">common_var_names</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
            
            <span class="n">adata_sub_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adata_list</span><span class="p">):</span>
                <span class="n">adata_sub</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">common_var_names</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">adata_sub</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">=</span> <span class="n">adata_sub</span><span class="o">.</span><span class="n">obs_names</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">shared_modality_sections</span><span class="p">[</span><span class="n">modality</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">adata_sub_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adata_sub</span><span class="p">)</span>


        <span class="n">adata_combined</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">adata_sub_list</span><span class="p">)</span>
        <span class="n">adata_combined</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;batch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;batch_</span><span class="si">{</span><span class="n">shared_modality_sections</span><span class="p">[</span><span class="n">modality</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> 
                                       <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adata_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

        
        <span class="n">adata_combined</span> <span class="o">=</span> <span class="n">preprocess_adata</span><span class="p">(</span><span class="n">adata_combined</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="n">hvg_num</span><span class="o">=</span><span class="n">hvg_num</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_harmony</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running Harmony for </span><span class="si">{</span><span class="n">modality</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">external</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">harmony_integrate</span><span class="p">(</span><span class="n">adata_combined</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;batch&#39;</span><span class="p">)</span>
            <span class="n">pca_data_combined</span> <span class="o">=</span> <span class="n">adata_combined</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_pca_harmony&#39;</span><span class="p">]</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pca_data_combined</span> <span class="o">=</span> <span class="n">adata_combined</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_pca&#39;</span><span class="p">]</span>
        

        <span class="c1"># split back to each section</span>
        <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_list</span><span class="p">])[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">combined_data_splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pca_data_combined</span><span class="p">,</span> <span class="n">split_indices</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shared_modality_sections</span><span class="p">[</span><span class="n">modality</span><span class="p">]):</span>
            <span class="n">key_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">modality</span><span class="si">}</span><span class="s1">_harmony&#39;</span> <span class="k">if</span> <span class="n">use_harmony</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">modality</span><span class="si">}</span><span class="s1">_pca&#39;</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="n">modality</span><span class="p">][</span><span class="n">section</span><span class="p">]</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="n">key_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_data_splits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">section</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_dict</span><span class="p">:</span>
                <span class="n">feature_dict</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">shared_data</span> <span class="o">=</span> <span class="n">combined_data_splits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">feature_dict</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">modality</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">shared_data</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">shared_data</span>


    <span class="c1"># Process unique modality</span>
    <span class="k">for</span> <span class="n">modality</span><span class="p">,</span> <span class="n">sections</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">modality</span> <span class="ow">in</span> <span class="n">shared_modalities</span><span class="p">:</span>
            <span class="k">continue</span>  

        <span class="k">for</span> <span class="n">section</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sections</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">adata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-------- Processing unique modality </span><span class="si">{</span><span class="n">modality</span><span class="si">}</span><span class="s1"> for section </span><span class="si">{</span><span class="n">section</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1"> --------&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">section</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_dict</span><span class="p">:</span>
                    <span class="n">feature_dict</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">adata_processed</span> <span class="o">=</span> <span class="n">preprocess_adata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="n">hvg_num</span><span class="o">=</span><span class="n">hvg_num</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">,</span> <span class="n">target_sum</span><span class="o">=</span><span class="n">target_sum</span><span class="p">)</span>
                <span class="n">pca_data</span> <span class="o">=</span> <span class="n">adata_processed</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_pca&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">modality</span><span class="p">][</span><span class="n">section</span><span class="p">]</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">modality</span><span class="si">}</span><span class="s1">_pca&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pca_data</span>
                <span class="n">feature_dict</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">modality</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">pca_data</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
                <span class="k">del</span> <span class="n">pca_data</span>
    <span class="n">feature_dict</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;s</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">feature_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="c1"># Process spatial location</span>
    <span class="k">for</span> <span class="n">section_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sections</span><span class="p">):</span> 
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Extracting spatial location for section </span><span class="si">{</span><span class="n">section_idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">spatial_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">modality</span><span class="p">,</span> <span class="n">sections</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">section_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sections</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sections</span><span class="p">[</span><span class="n">section_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;spatial&#39;</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">[</span><span class="n">section_idx</span><span class="p">]</span><span class="o">.</span><span class="n">obsm</span><span class="p">:</span>
                <span class="n">spatial_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sections</span><span class="p">[</span><span class="n">section_idx</span><span class="p">]</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">spatial_loc_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;s</span><span class="si">{</span><span class="n">section_idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spatial_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">spatial_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">spatial_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spatial</span><span class="p">)</span> <span class="k">for</span> <span class="n">spatial</span> <span class="ow">in</span> <span class="n">spatial_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">spatial_loc_dict</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;s</span><span class="si">{</span><span class="n">section_idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spatial_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Section </span><span class="si">{</span><span class="n">section_idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> contains inconsistent spatial information across different modalities!&quot;</span><span class="p">)</span>


    <span class="k">return</span> <span class="n">feature_dict</span><span class="p">,</span> <span class="n">spatial_loc_dict</span><span class="p">,</span> <span class="n">data_dict</span></div>





<span class="c1">### CLR normalization for protein borrowed from SpatialGLUE</span>
<div class="viewcode-block" id="clr_normalize_each_cell">
<a class="viewcode-back" href="../../api/COSIE.data_preprocessing.clr_normalize_each_cell.html#COSIE.data_preprocessing.clr_normalize_each_cell">[docs]</a>
<span class="k">def</span> <span class="nf">clr_normalize_each_cell</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize each cell&#39;s protein counts using Centered Log-Ratio (CLR) normalization,</span>
<span class="sd">    following the approach used in Seurat and SpatialGLUE.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">        Input AnnData object where `.X` stores raw count data (e.g., protein abundance).</span>
<span class="sd">    </span>
<span class="sd">    inplace : bool, optional</span>
<span class="sd">        Whether to modify the input `adata` in place. If True, the normalization will overwrite `adata.X`. If False, a normalized copy of `adata` is returned. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">        The AnnData object with CLR-normalized `.X`. If `inplace=True`, returns the modified input object; if `inplace=False`, returns a new normalized copy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">seurat_clr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">exp</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
        <span class="n">seurat_clr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">A</span> <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">adata</span>  </div>




<div class="viewcode-block" id="metacell_construction_optimized">
<a class="viewcode-back" href="../../api/COSIE.data_preprocessing.metacell_construction_optimized.html#COSIE.data_preprocessing.metacell_construction_optimized">[docs]</a>
<span class="k">def</span> <span class="nf">metacell_construction_optimized</span><span class="p">(</span><span class="n">adata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct metacells by aggregating every 2×2 spatially adjacent grid of cells into one,</span>
<span class="sd">    using integer grid grouping for O(n) performance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">        An AnnData object with .obsm[&#39;spatial&#39;] coords and .X expr. matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    adata_metacell : AnnData</span>
<span class="sd">        New AnnData of metacells with averaged expression and coords, plus mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>
    <span class="c1"># Extract coords and expression</span>
    <span class="n">spatial</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span>
    <span class="c1"># handle sparse</span>
    <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

    <span class="c1"># Compute grid origin and step sizes</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">spatial</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">];</span> <span class="n">x</span> <span class="o">=</span> <span class="n">spatial</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">uniq_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="n">uniq_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">uniq_y</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">uniq_x</span><span class="p">)</span>
    <span class="c1"># choose smallest non-zero step</span>
    <span class="n">step_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dy</span><span class="p">[</span><span class="n">dy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">step_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="n">dx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Map to integer grid</span>
    <span class="n">grid_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="n">step_y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">grid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">step_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Block coordinates for 2x2 grouping</span>
    <span class="n">block_y</span> <span class="o">=</span> <span class="n">grid_y</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">block_x</span> <span class="o">=</span> <span class="n">grid_x</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Group indices by block</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">bx</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">block_y</span><span class="p">,</span> <span class="n">block_x</span><span class="p">)):</span>
        <span class="n">blocks</span><span class="p">[(</span><span class="n">by</span><span class="p">,</span> <span class="n">bx</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="c1"># Aggregate each block</span>
    <span class="n">meta_expr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meta_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meta_to_original</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">bx</span><span class="p">),</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">blocks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">meta_to_original</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="c1"># mean expression and coords</span>
        <span class="n">meta_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">meta_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spatial</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Build new AnnData</span>
    <span class="n">meta_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">meta_expr</span><span class="p">)</span>
    <span class="n">adata_meta</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">AnnData</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">meta_X</span><span class="p">)</span>
    <span class="n">adata_meta</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">adata_meta</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">meta_coords</span><span class="p">)</span>
    <span class="n">adata_meta</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;meta_to_original&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_to_original</span>
    <span class="n">adata_meta</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;original_cell_num&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span>

    <span class="k">return</span> <span class="n">adata_meta</span></div>





<span class="c1"># def metacell_construction(adata):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Construct metacells by aggregating every 2×2 spatially adjacent grid of cells into one,</span>
<span class="c1">#     to reduce memory usage and speed up computation.</span>

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     adata : AnnData</span>
<span class="c1">#         An AnnData object. The spatial coordinates should be stored in `adata.obsm[&#39;spatial&#39;]`. The expression matrix `adata.X` can be either dense or sparse.</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     adata_metacell : AnnData</span>
<span class="c1">#         A new AnnData object where each observation (cell) corresponds to a metacell,</span>
<span class="c1">#         formed by averaging a group of up to 4 adjacent spatial cells (in a 2×2 pattern).</span>

<span class="c1">#         The returned object includes:</span>
        
<span class="c1">#         - `.X`: Averaged expression matrix across grouped cells.  </span>
<span class="c1">#         - `.obsm[&#39;spatial&#39;]`: Spatial coordinates (mean of each group).  </span>
<span class="c1">#         - `.uns[&#39;meta_to_original&#39;]`: A list mapping each metacell to the indices of original cells it includes.  </span>
<span class="c1">#         - `.uns[&#39;original_cell_num&#39;]`: Total number of original cells before metacell construction.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     spatial_coords = adata.obsm[&#39;spatial&#39;]  </span>
<span class="c1">#     expression = adata.X.toarray() if scipy.sparse.issparse(adata.X) else adata.X</span>

<span class="c1">#     # sort (y, x)</span>
<span class="c1">#     sorted_indices = np.lexsort((spatial_coords[:, 0], spatial_coords[:, 1]))</span>
<span class="c1">#     sorted_coords = spatial_coords[sorted_indices]</span>
<span class="c1">#     sorted_expression = expression[sorted_indices]</span>

<span class="c1">#     meta_cells = []</span>
<span class="c1">#     meta_coords = []</span>
<span class="c1">#     meta_to_original = []  </span>
<span class="c1">#     visited = set()</span>

<span class="c1">#     # visit each cell</span>
<span class="c1">#     for i in range(len(sorted_coords)):</span>
<span class="c1">#         if i in visited:</span>
<span class="c1">#             continue</span>

<span class="c1">#         # current cell</span>
<span class="c1">#         group_indices = [i]</span>
<span class="c1">#         visited.add(i)</span>

<span class="c1">#         # neighbors</span>
<span class="c1">#         right = None</span>
<span class="c1">#         down = None</span>
<span class="c1">#         diag = None</span>

<span class="c1">#         for j in range(i + 1, len(sorted_coords)):</span>
<span class="c1">#             if j in visited:</span>
<span class="c1">#                 continue</span>
<span class="c1">#             dx = sorted_coords[j][0] - sorted_coords[i][0]</span>
<span class="c1">#             dy = sorted_coords[j][1] - sorted_coords[i][1]</span>

<span class="c1">#             if right is None and dx &gt; 0 and dy == 0: </span>
<span class="c1">#                 right = j</span>
<span class="c1">#                 visited.add(j)</span>
<span class="c1">#             elif down is None and dx == 0 and dy &gt; 0: </span>
<span class="c1">#                 down = j</span>
<span class="c1">#                 visited.add(j)</span>
<span class="c1">#             elif diag is None and dx &gt; 0 and dy &gt; 0:  </span>
<span class="c1">#                 diag = j</span>
<span class="c1">#                 visited.add(j)</span>


<span class="c1">#             if right is not None and down is not None and diag is not None:</span>
<span class="c1">#                 break</span>

<span class="c1">#         if right is not None and down is not None and diag is not None:</span>
<span class="c1">#             group_indices.extend([right, down, diag])</span>

<span class="c1">#         original_indices = sorted_indices[group_indices]</span>
<span class="c1">#         meta_to_original.append(original_indices.tolist())</span>

<span class="c1">#         merged_expression = sorted_expression[group_indices].mean(axis=0)</span>
<span class="c1">#         merged_coords = sorted_coords[group_indices].mean(axis=0)</span>
        

<span class="c1">#         meta_cells.append(merged_expression)</span>
<span class="c1">#         meta_coords.append(merged_coords)</span>


<span class="c1">#     # build new adata</span>
<span class="c1">#     meta_X = np.vstack(meta_cells)</span>
<span class="c1">#     meta_coords = np.array(meta_coords)</span>
<span class="c1">#     adata_metacell = sc.AnnData(X=meta_X)</span>
<span class="c1">#     adata_metacell.var_names = adata.var_names.copy()</span>
<span class="c1">#     adata_metacell.obsm[&#39;spatial&#39;] = meta_coords</span>
<span class="c1">#     # adata_metacell.uns[&#39;meta_to_original&#39;] = [json.dumps(indices) for indices in meta_to_original]</span>
<span class="c1">#     adata_metacell.uns[&#39;meta_to_original&#39;] = meta_to_original</span>
<span class="c1">#     adata_metacell.uns[&#39;original_cell_num&#39;] = adata.n_obs</span>
<span class="c1">#     adata_metacell.X = np.array(adata_metacell.X)</span>

<span class="c1">#     return adata_metacell</span>



<div class="viewcode-block" id="construct_metacell_data_dict">
<a class="viewcode-back" href="../../api/COSIE.data_preprocessing.construct_metacell_data_dict.html#COSIE.data_preprocessing.construct_metacell_data_dict">[docs]</a>
<span class="k">def</span> <span class="nf">construct_metacell_data_dict</span><span class="p">(</span><span class="n">data_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply metacell construction to all available AnnData objects in a multimodal dataset dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_dict : dict</span>
<span class="sd">        A dictionary where each key is a modality name (e.g., `&#39;RNA&#39;`, `&#39;Protein&#39;`) and each value</span>
<span class="sd">        is a list of AnnData objects, one per tissue section. Each AnnData should contain:</span>
<span class="sd">        </span>
<span class="sd">        - `.X`: Expression or feature matrix (dense or sparse)  </span>
<span class="sd">        - `.obs`, `.var`: Standard metadata  </span>
<span class="sd">        - `.obsm[&#39;spatial&#39;]`: 2D spatial coordinates</span>

<span class="sd">        If a modality is missing in a section, use `None` to indicate it.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    metacell_dict : dict</span>
<span class="sd">        A new dictionary with the same structure as `data_dict`, where each AnnData object has been replaced by its metacell-aggregated version, created using `metacell_construction_optimized()`. The modality and section alignment are preserved.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">metacell_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">modality</span><span class="p">,</span> <span class="n">adata_list</span> <span class="ow">in</span> <span class="n">data_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">adata_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># new_adata = metacell_construction(adata)</span>
                <span class="n">new_adata</span> <span class="o">=</span> <span class="n">metacell_construction_optimized</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
                <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_adata</span><span class="p">)</span>
        <span class="n">metacell_dict</span><span class="p">[</span><span class="n">modality</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_list</span>

    <span class="k">return</span> <span class="n">metacell_dict</span></div>






<div class="viewcode-block" id="reconstruct_metacell_to_original">
<a class="viewcode-back" href="../../api/COSIE.data_preprocessing.reconstruct_metacell_to_original.html#COSIE.data_preprocessing.reconstruct_metacell_to_original">[docs]</a>
<span class="k">def</span> <span class="nf">reconstruct_metacell_to_original</span><span class="p">(</span><span class="n">adata_metacell</span><span class="p">,</span> <span class="n">metacell_embedding</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand metacell-level embeddings back to individual cells based on the</span>
<span class="sd">    metacell-to-original cell mapping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata_metacell : AnnData</span>
<span class="sd">        An AnnData object generated by `metacell_construction()`. It must contain:</span>
<span class="sd">        </span>
<span class="sd">        - `.uns[&#39;meta_to_original&#39;]`: A list of lists, where each sublist contains the indices of original cells belonging to a given metacell.</span>
<span class="sd">        - `.uns[&#39;original_cell_num&#39;]`: Total number of original cells before metacell construction.</span>
<span class="sd">    </span>
<span class="sd">    metacell_embedding : np.ndarray</span>
<span class="sd">        An array of shape (n_metacells, d), representing the learned embedding for each metacell.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    original_embedding : np.ndarray</span>
<span class="sd">        An array of shape (n_original_cells, d), where each original cell inherits the embedding of its corresponding metacell.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">meta_to_original</span> <span class="o">=</span> <span class="n">adata_metacell</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;meta_to_original&#39;</span><span class="p">]</span>
    <span class="n">original_cell_num</span> <span class="o">=</span> <span class="n">adata_metacell</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;original_cell_num&#39;</span><span class="p">]</span>

    <span class="c1"># initialize full-size embedding matrix</span>
    <span class="n">original_embedding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">original_cell_num</span><span class="p">,</span> <span class="n">metacell_embedding</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">meta_idx</span><span class="p">,</span> <span class="n">original_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">meta_to_original</span><span class="p">):</span>
        <span class="n">original_embedding</span><span class="p">[</span><span class="n">original_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">metacell_embedding</span><span class="p">[</span><span class="n">meta_idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">original_embedding</span></div>























<span class="c1">###</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Mingyao Li Lab, 2025.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>